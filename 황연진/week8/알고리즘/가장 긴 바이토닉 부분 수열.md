# 문제
백준 - 가장 긴 바이토닉 부분 수열 (G4)
https://www.acmicpc.net/problem/11054


# 풀이

```Kotlin
import kotlin.math.*

fun main() {
    val br = System.`in`.bufferedReader()
    val n = br.readLine().toInt()
    val arr = br.readLine().split(" ").map { it.toInt() }.toIntArray()
    val dpInc = IntArray(n) { 1 }
    val dpDec = IntArray(n) { 1 }

    for (i in 1 until n) {
        for (j in 0 until i) {
            if (arr[i] > arr[j]) {
                dpInc[i] = max(dpInc[i], dpInc[j] + 1)
            }
        }
    }

    for (i in n - 2 downTo 0) {
        for (j in n - 1 downTo i + 1) {
            if (arr[i] > arr[j]) {
                dpDec[i] = max(dpDec[i], dpDec[j] + 1)
            }
        }
    }

    println((0 until n).maxOf { dpInc[it] + dpDec[it] - 1})
}
```


# 해설
## 💡 이 문제에서 말하는 "바이토닉 수열"의 정의

> 어떤 수열이 증가하는 부분 수열과 감소하는 부분 수열으로 나뉘어질 수 있다면, 그 수열은 바이토닉 수열이다.
>

즉, "무조건 오르다가 내려야 한다"는 조건이 아니라:

- **처음부터 끝까지 증가** → 감소 파트가 "길이 0"인 바이토닉
- **처음부터 끝까지 감소** → 증가 파트가 "길이 0"인 바이토닉
- **중간에 꼭짓점이 있는 경우** → 일반적인 바이토닉

---

### 📘 다시 정리하면:

| 수열 | 바이토닉인가? | 이유 |
| --- | --- | --- |
| `{10, 20, 30, 25, 20}` | ✅ | 증가하다가 감소 |
| `{10, 20, 30, 40}` | ✅ | 증가만 있음 (감소는 없음) |
| `{50, 40, 25, 10}` | ✅ | 감소만 있음 (증가는 없음) |

> 즉, "바이토닉 = 증가 + 감소",
>
>
> 이때 증가 파트 또는 감소 파트가 **0개여도 허용**된다는 말
>

## ✅ 바이토닉 수열 문제에서는?

보통 문제에서는 이렇게 물어봄:

> 어떤 수열이 주어질 때, 가장 긴 바이토닉 부분 수열의 길이를 구하시오.
>

즉, 주어진 숫자들 중에서 순서를 유지하면서

**증가 → 감소 형태로 고를 수 있는 가장 긴 부분 수열**을 찾기

---

## ✨ 그럼 어떻게 풀까? (아이디어)

1. **앞에서부터 LIS**: 각 원소를 끝으로 하는 증가 수열 길이 구함
2. **뒤에서부터 LIS**: 각 원소를 시작으로 하는 감소 수열 길이 구함
3. **두 값을 합쳐서 -1**

   (중앙 값은 중복되니까 한 번 빼줘야함)


## 🔁 기본적인 LIS for문 구조 다시 보기

```kotlin
for (i in 0 until n) {
    for (j in 0 until i) {
        if (a[j] < a[i]) {
            dp[i] = maxOf(dp[i], dp[j] + 1)
        }
    }
}
```

### ❓ 왜 i는 0부터 시작하는가?

- i = 0일 때, 내부 for문은 `0 until 0`이니까 → **한 번도 안 돌음**
- 즉, i = 0일 때는 "자기 자신 하나로만 수열을 구성" → `dp[0] = 1`
- 이후 i = 1부터는, 앞에 비교할 j가 생기면서 본격적으로 비교가 시작

그래서 **이 방식에서는 i = 0부터 시작해도 문제 없음**

즉, dp[i] 초기값을 `1`로 두면 i=0일 때 자연스럽게 반영

---

## 🧭 그럼 바이토닉에서는 왜 `1부터` 시작?

이건 **깔끔한 구현과 불필요한 비교 제거**를 위한 거야!

```kotlin
for (i in 1 until n) {
    for (j in 0 until i) {
        if (a[j] < a[i]) {
            inc[i] = maxOf(inc[i], inc[j] + 1)
        }
    }
}
```

- i = 0일 땐 어차피 j < i 조건을 만족할 j가 없음
- 즉, i = 0일 땐 내부 for문이 아예 안 돎
- 그럼 굳이 돌릴 필요가 없으니까 **i = 1부터 시작하면 효율적**

## 🔍 헷갈릴 수 있는 부분 비교

| 코드 | 의미 | 올바른가? |
| --- | --- | --- |
| `(0 until n).maxOf { inc[it] + dec[it] - 1 }` | **같은 위치**의 증가 + 감소 수열 길이를 합친 것 | ✅ |
| `inc.max() + dec.max() - 1` | **서로 다른 위치**에서 가장 긴 증가, 감소 수열을 합친 것 | ❌ |

---

## 🎯 왜 `inc.max() + dec.max() - 1`은 틀릴까?

이 문제는 **"하나의 꼭짓점(i)"를 기준으로**
왼쪽은 **증가**, 오른쪽은 **감소**해야 바이토닉 수열임.
즉, `i`라는 **같은 위치**를 기준으로 양쪽 길이를 더해야 된다.
그런데 `inc.max()`는 어떤 위치에서 가장 길게 증가한 걸 의미하고,
`dec.max()`는 또 **다른 위치**에서 가장 길게 감소한 걸 의미한다.
그래서 두 개를 더하면 **서로 무관한 두 위치**의 값을 더하게 돼서
**바이토닉 수열**이 아닌 **두 개의 다른 수열 길이 합**이 되어버린다.